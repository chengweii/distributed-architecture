# 针对电商分布式系统的基础架构实现

# 环境搭建
## 整体架构

## Mysql集群

## Redis集群
![sharding cluster](doc/redis_sharding_cluster.jpg)  
负载均衡针对不同的场景采用不同的方式实现：
* 针对普通缓存通过客户端分片机制的ShardedJedisPool实现。  
* 针对分布式ID业务通过客户端随机获取一个redis服务单写的方式实现。
* 分布式锁业务不需要做负载均衡，不同业务系统单独部署对应Redis集群就好。
高可用针对不同的场景采用不同的方式实现：  
* 针对分布式锁业务对缓存数据一致性要求很高的场景，无法通过主从模式保证强一致性，所以目前通过多写的方式来实现，虽然一定程度上降低了性能，但保证了强一致性要求下的高可用。
* 针对普通读缓存业务对缓存数据一致性要求不高的场景，可以不用保证高可用，通过单写，获取失败重新加载缓存的方式实现即可。
* ShardedJedisPool 无法处理结点宕机问题，需要在结点异常时通过 zookeeper 获取最新的可访问结点列表重新初始化 ShardedJedisPool。
    * https://gitee.com/zhanggaofeng/redis-proxy
    * https://github.com/smallvq123/redis-ha-proxy

## RabbitMQ集群

## Zookeeper集群

## config-toolkit
具体配置服务部署参考config-toolkit的<a href="https://github.com/dangdangdotcom/config-toolkit">github</a>

## 分布式环境各场景采用方案
### 分布式事务
关于分布式环境下的各个服务的事务均采用Spring事务管理器实现本地事务，而分布式服务之间的事务采用MQ消息实现最终一致的全局事务。

### 分布式Session
分布式环境下的Session采用独立的Redis集群进行管理。

### 分布式ID
设计单独的分布式ID获取服务，该服务通过Redis集群的incr获取自增id保证原子操作。
* 各Redis分片存储不同区段的ID list，客户端获取一个删除一个，客户端使用相同key获取，通过在redis服务列表中随机取一个做负载均衡。
* 客户端获取id通过lu脚本：获取当前id区段的id，如果获取达到上限则将预备id区段覆盖到当前id区段并删除预备id区段，最后再次从当前id区段中获取id。
* 定时调度检查各分片当前id区段使用情况，提前加载预备id区段到缓存中，已用区段在数据库中记录，便于Redis重启后恢复。
* 为了保证id获取性能，未对id使用实时记录，可能会存在部分id重启后无法完全恢复的情况。

第二种方式：
在不同的redis分片中设置不同的id初始值（1、2、3、4、5），增长步长同为分片数量5，则各分片不会出现交集，简单但是可能会造成数据不连续

第三种方式：
多写的方式，同时写两台Redis，为了保证恢复宕机服务的ID唯一，在写入前需要检查结点是否存在该ID，不存在则直接创建ID同时同步最新的ID值

### 分布式锁
分布式环境下的锁服务通过Redis集群环境下的setnx方式实现分布式并发同步控制。需要注意如下几点：
* 为了避免宕机情况引起的锁定失败，在集群中至少一半以上的结点上设置锁成功才算最终锁定成功
* 为了避免因为在集群各结点设置锁顺序不一致而导致在锁失效时间内死锁的情况出现，设置锁集群结点的顺序必须一致
* 为了避免因为主从同步不一致情况而引起的锁定失败，集群不再通过主备模式保证高可用，客户端+多个Redis结点方式已经可以保证高可用
* 实现上除了通过 jedis 客户端 + redis 服务 的方式，还可以通过 Nginx lua + redis 服务 的方式，后者可以将分布式锁的实现细节与客户端解耦，当然本地也可以通过单独服务或SDK的方式解耦分布式锁的具体实现细节